<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>在庫管理システム</title>

<script src="https://unpkg.com/@supabase/supabase-js@2"></script>

<style>
  :root{
    --bg:#f6f7fb;
    --card:#ffffff;
    --text:#111827;
    --muted:#6b7280;
    --line:#e5e7eb;

    --primary:#2563eb;
    --primaryHover:#1d4ed8;
    --danger:#dc2626;
    --dangerHover:#b91c1c;
    --ghost:#e5e7eb;
    --ghostHover:#d1d5db;

    --goodBg:#ecfdf5;
    --goodLine:#86efac;
    --badBg:#fff1f2;
    --badLine:#fca5a5;

    --lowBg:#fff1f2;
    --lowText:#9f1239;

    --radius:14px;
    --shadow:0 8px 24px rgba(17,24,39,.08);
  }

  *{ box-sizing:border-box; }
  body{
    margin:0;
    font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Hiragino Sans", "Noto Sans JP", "Helvetica Neue", Arial;
    color:var(--text);
    background:var(--bg);
  }

  code{
    background:#f3f4f6;
    padding:2px 6px;
    border-radius:8px;
    font-size: 12px;
  }

  .container{
    max-width: 1280px;
    margin: 0 auto;
    padding: 18px;
  }

  header{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap: 12px;
    margin-bottom: 14px;
    flex-wrap:wrap;
  }

  .title{
    display:flex;
    flex-direction:column;
    gap:2px;
  }
  h1{
    font-size: 22px;
    margin:0;
    letter-spacing: .02em;
  }
  .subtitle{
    color: var(--muted);
    font-size: 13px;
  }

  .topActions{
    display:flex;
    gap:8px;
    flex-wrap:wrap;
    align-items:center;
    justify-content:flex-end;
  }

  .card{
    background:var(--card);
    border:1px solid var(--line);
    border-radius: var(--radius);
    box-shadow: var(--shadow);
    padding: 14px;
  }

  .grid{
    display:grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px;
  }
  .grid3{
    display:grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap: 12px;
  }

  @media (max-width: 980px){
    .grid, .grid3{ grid-template-columns: 1fr; }
  }

  .sectionTitle{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap: 8px;
    margin: 0 0 10px 0;
  }
  .sectionTitle h2{
    margin:0;
    font-size: 16px;
  }
  .hint{
    color:var(--muted);
    font-size: 12px;
  }

  #status{
    padding: 10px 12px;
    border-radius: 12px;
    border: 1px solid var(--line);
    background: #fff;
    margin-bottom: 12px;
    font-size: 13px;
  }
  #status.good{ background: var(--goodBg); border-color: var(--goodLine); }
  #status.bad{ background: var(--badBg); border-color: var(--badLine); }

  .row{
    display:flex;
    gap: 10px;
    flex-wrap:wrap;
    align-items:center;
  }

  .field{
    display:flex;
    flex-direction:column;
    gap:6px;
    min-width: 180px;
    flex: 1;
  }
  .field label{
    font-size: 12px;
    color: var(--muted);
  }

  input[type="text"], input[type="password"], input[type="number"], input[type="date"], input[type="month"], select{
    width: 100%;
    padding: 10px 12px;
    border-radius: 12px;
    border:1px solid var(--line);
    outline: none;
    background:#fff;
    font-size: 14px;
  }
  input:focus, select:focus{
    border-color: rgba(37,99,235,.55);
    box-shadow: 0 0 0 4px rgba(37,99,235,.12);
  }

  input[type="file"]{ padding: 10px 0; }

  button{
    border: none;
    border-radius: 12px;
    padding: 10px 12px;
    cursor: pointer;
    font-size: 14px;
    transition: transform .02s ease, background .15s ease, opacity .15s ease;
    user-select:none;
    white-space:nowrap;
  }
  button:active{ transform: translateY(1px); }
  button:disabled{ opacity:.55; cursor:not-allowed; }

  .btn-primary{ background: var(--primary); color: #fff; }
  .btn-primary:hover{ background: var(--primaryHover); }

  .btn-danger{ background: var(--danger); color: #fff; }
  .btn-danger:hover{ background: var(--dangerHover); }

  .btn-ghost{ background: var(--ghost); color: var(--text); }
  .btn-ghost:hover{ background: var(--ghostHover); }

  .btn-small{
    padding: 7px 10px;
    border-radius: 10px;
    font-size: 13px;
  }

  .tableCard{ padding: 0; overflow: hidden; }
  .tableHeader{
    padding: 12px 14px;
    border-bottom: 1px solid var(--line);
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap: 10px;
    flex-wrap:wrap;
  }
  .tableHeader h2{
    margin:0;
    font-size: 16px;
  }
  .tableWrap{
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
  }

  /* 表っぽく：罫線 */
  table{
    width: 100%;
    border-collapse: collapse;
    min-width: 1180px;
    background: #fff;
    border: 1px solid var(--line);
  }
  th, td{
    padding: 12px 12px;
    text-align: left;
    font-size: 14px;
    border: 1px solid var(--line);
    vertical-align: top;
  }
  th{
    background: #fafafa;
    color:#374151;
    font-weight: 800;
    position: sticky;
    top: 0;
    z-index: 1;
  }

  td.qty{
    text-align: right;
    font-variant-numeric: tabular-nums;
    font-weight: 800;
    white-space: nowrap;
  }
  td.center{ text-align:center; }
  .muted{ color:var(--muted); font-size: 12px; }

  tr.low-stock td{
    background: var(--lowBg);
    color: var(--lowText);
  }

  /* 商品名を見やすく */
  td.nameCell{
    min-width: 340px;
    max-width: 560px;
    white-space: normal;
    word-break: break-word;
    font-size: 13px;
    line-height: 1.35;
  }

  .pill{
    display:inline-flex;
    align-items:center;
    gap: 6px;
    padding: 6px 10px;
    border: 1px solid var(--line);
    border-radius: 999px;
    font-size: 12px;
    color: var(--muted);
    background:#fff;
  }

  .kv{
    display:flex;
    gap:10px;
    flex-wrap:wrap;
    align-items:center;
  }
  .kv b{
    font-variant-numeric: tabular-nums;
  }

  details > summary{
    cursor:pointer;
    user-select:none;
    color:#111827;
    font-weight:800;
    list-style:none;
  }
  details > summary::-webkit-details-marker{ display:none; }
  details{
    border:1px solid var(--line);
    border-radius: 12px;
    padding: 10px 12px;
    background:#fff;
  }

  .badge{
    display:inline-flex;
    align-items:center;
    gap:6px;
    padding:4px 8px;
    border:1px solid var(--line);
    border-radius:999px;
    font-size:11px;
    color:var(--muted);
    background:#fff;
    margin-left:8px;
    white-space:nowrap;
  }
  .badge b{ color:#111827; }
  .badgeGroup{
    display:inline-flex;
    gap:6px;
    flex-wrap:wrap;
    justify-content:flex-end;
    margin-top:6px;
  }

  @media (max-width: 600px){
    .row.actions{ flex-direction: column; align-items: stretch; }
    .row.actions button{ width: 100%; }
    table{ min-width: 1280px; }
  }
</style>
</head>

<body>
<div class="container">

  <header>
    <div class="title">
      <h1>在庫管理システム</h1>
      <div class="subtitle">UI v8 / 検索・不足表示・履歴フィルタ・棚卸差分レポート / 出庫：直近3ヶ月（月別）+ SKU別6ヶ月（月別）</div>
    </div>

    <div class="topActions">
      <button class="btn-ghost" onclick="loadAll()">最新に更新</button>
      <span class="pill">既定アラート: <b id="alertBadge">3</b>（SKU別に上書き可）</span>
      <span class="pill">表示: <b id="viewBadge">全件</b></span>
    </div>
  </header>

  <div id="status" class="good">状態: 起動中…</div>

  <!-- 1) 検索 / 2) 不足だけ表示 -->
  <div class="card" style="margin-bottom:12px;">
    <div class="sectionTitle">
      <h2>検索 / 表示</h2>
      <div class="hint">SKU/商品名で絞り込み。不足だけ表示も可能</div>
    </div>
    <div class="row actions">
      <div class="field" style="min-width:320px;">
        <label>検索（SKU または 商品名）</label>
        <input id="stockSearch" type="text" placeholder="例: A001 / りんご" oninput="applyStockView()" />
      </div>

      <div class="field" style="max-width:240px;">
        <label>表示モード</label>
        <select id="stockViewMode" onchange="applyStockView()">
          <option value="all">全件</option>
          <option value="low">不足だけ（qty &lt; alert）</option>
        </select>
      </div>

      <div class="field" style="max-width:240px;">
        <label>一覧ハイライト条件</label>
        <select id="highlightMode" onchange="applyStockView()">
          <option value="le">赤ハイライト: qty ≤ alert</option>
          <option value="lt">赤ハイライト: qty &lt; alert</option>
        </select>
      </div>

      <button class="btn-ghost" onclick="resetStockView()">絞り込みクリア</button>
    </div>

    <div class="kv muted" style="margin-top:10px;">
      <span>不足判定（不足CSV/不足表示）: <b>qty &lt; alert</b></span>
      <span>差 = max(0, alert - qty)</span>
      <span class="pill">直近3ヶ月（月別）: <b id="out3Label">-</b></span>
    </div>
  </div>

  <div class="grid">
    <div class="card">
      <div class="sectionTitle">
        <h2>編集PIN</h2>
        <div class="hint">※PINはブラウザに記憶されます</div>
      </div>
      <div class="row">
        <div class="field" style="max-width:260px;">
          <label>PIN（操作する人だけ入力）</label>
          <input id="pinInput" type="password" placeholder="PIN" />
        </div>
        <button class="btn-ghost" onclick="clearSavedPin()">PINを忘れる</button>
      </div>
      <div class="muted" style="margin-top:10px;">
        閲覧は誰でもOK / 編集はPIN入力が必要
      </div>
    </div>

    <div class="card">
      <div class="sectionTitle">
        <h2>ユーザー名（履歴用）</h2>
        <div class="hint">※未入力でもOK</div>
      </div>
      <div class="row">
        <div class="field" style="max-width:260px;">
          <label>履歴に残す名前</label>
          <input id="userInput" placeholder="例：山田" />
        </div>
      </div>
      <div class="muted" style="margin-top:10px;">
        「誰が操作したか」を残したいときに入力
      </div>
    </div>
  </div>

  <!-- 入庫（メイン） -->
  <div class="card" style="margin-top:12px;">
    <div class="sectionTitle">
      <h2>入庫（手入力）</h2>
      <div class="hint">SKU必須 / 商品名は任意 / アラート閾値も設定可</div>
    </div>

    <div class="row actions">
      <div class="field">
        <label>SKU（必須）</label>
        <input id="skuInput" placeholder="SKU（必須）" />
      </div>
      <div class="field">
        <label>商品名（任意）</label>
        <input id="nameInput" placeholder="商品名（任意）" />
      </div>
      <div class="field" style="max-width:160px;">
        <label>数量（入庫）</label>
        <input id="qtyInput" type="number" placeholder="例：10" />
      </div>
      <div class="field" style="max-width:220px;">
        <label>アラート閾値（任意）</label>
        <input id="alertInput" type="number" placeholder="例：3（空欄＝既定）" />
      </div>
      <button class="btn-primary" onclick="addItemManual()">数量入庫</button>
    </div>

    <div class="muted" style="margin-top:8px;">
      SKUが既に存在する場合は在庫を加算（商品名/閾値は入力があれば更新）
    </div>
  </div>

  <!-- CSV / メンテ（メイン） -->
  <div class="card" style="margin-top:12px;">
    <div class="sectionTitle">
      <h2>CSV / メンテ</h2>
      <div class="hint">在庫CSVインポート / 棚卸CSV / 発注アシスト / 出庫CSV（指定月で履歴に反映）</div>
    </div>

    <div class="row actions" style="margin-top:6px;">
      <button class="btn-ghost" onclick="bulkFillAlertQty()">未設定のalert_qtyを既定値に一括設定</button>
      <span class="muted">（既定: <b id="alertLabel">3</b>）</span>
    </div>

    <details style="margin-top:12px;">
      <summary>発注アシスト（不足 → 発注CSV）</summary>
      <div class="muted" style="margin-top:10px; line-height:1.65;">
        不足CSVをベースに「発注数」を入れて発注CSVを作ります（在庫は変更しません）。
      </div>

      <div class="row actions" style="margin-top:10px;">
        <button class="btn-primary" onclick="openOrderAssist()">不足から作成</button>
        <button class="btn-ghost" onclick="downloadOrderCSV()">発注CSVをDL</button>
        <span class="pill">行数: <b id="orderCount">0</b></span>
      </div>

      <div class="tableWrap" style="margin-top:10px;">
        <table id="orderTable" style="min-width:1080px;"></table>
      </div>

      <div class="muted" style="margin-top:10px;">
        出力: <code>sku,name,qty,alert_qty,shortage,order_qty</code>
      </div>
    </details>

    <details style="margin-top:12px;">
      <summary>在庫CSVインポート（増減/上書き）</summary>
      <div style="margin-top:10px;">
        <div class="row">
          <input type="file" accept=".csv,text/csv" onchange="importStocksCSV(this)" />
        </div>
        <div class="muted" style="margin-top:8px; line-height:1.55;">
          形式A（増減）：<code>sku,name,delta,alert_qty</code><br>
          形式B（上書き）：<code>sku,name,qty,alert_qty</code><br>
          ※skuが空ならname照合。qty=0は削除扱い。alert_qty空欄は既存維持（新規は既定）。
        </div>
      </div>
    </details>

    <details style="margin-top:12px;">
      <summary>棚卸CSVインポート（実在個で上書き）</summary>
      <div style="margin-top:10px;">
        <div class="row">
          <input type="file" accept=".csv,text/csv" onchange="importStocktakeCSV(this)" />
        </div>
        <div class="muted" style="margin-top:8px; line-height:1.55;">
          形式：<code>sku,name,qty</code>（ヘッダあり/なし両対応。2列なら <code>sku,qty</code>）<br>
          ※CSVにあるSKUだけ上書き（差分は履歴に <code>棚卸</code>）。nameが空なら既存維持、入っていれば更新。
        </div>
      </div>
    </details>

    <details style="margin-top:12px;">
      <summary>出庫CSVを取り込み（指定した月の出庫として履歴に追加）</summary>
      <div class="muted" style="margin-top:10px; line-height:1.65;">
        これは <b>在庫数は変更せず</b>、分析用に履歴（history）へ「その月の出庫」として追加します。<br>
        形式：<code>sku,name,qty</code> または <code>sku,qty</code>（ヘッダあり/なしOK）
      </div>

      <div class="row actions" style="margin-top:10px;">
        <div class="field" style="max-width:240px;">
          <label>何月の出庫？</label>
          <input id="shipMonth" type="month" />
        </div>
        <div class="field">
          <label>出庫CSV</label>
          <input id="shipCsv" type="file" accept=".csv,text/csv" />
        </div>
        <button class="btn-primary" onclick="importShipmentCSV()">この月の出庫として追加</button>
      </div>

      <div class="muted" style="margin-top:8px;">
        履歴の種別は <code>CSV出庫</code> で入ります（SKU別の月次集計に反映されます）。
      </div>
    </details>
  </div>

  <!-- 在庫一覧（メイン） -->
  <div class="card tableCard" style="margin-top:12px;">
    <div class="tableHeader">
      <h2>在庫一覧</h2>
      <div class="hint">SKU昇順 / 表示は上の検索・モードで切替（数量欄に直近3ヶ月の出庫をバッジ表示）</div>
    </div>
    <div class="tableWrap">
      <table id="stockTable"></table>
    </div>
  </div>

  <!-- SKU別：直近6ヶ月（月別）出庫（折りたたみ） -->
  <details style="margin-top:12px;">
    <summary>SKU別 出庫（月別・直近6ヶ月）</summary>
    <div class="card" style="margin-top:10px; box-shadow:none;">
      <div class="sectionTitle" style="margin-bottom:8px;">
        <h2 style="font-size:15px;">SKU別 出庫（月別）</h2>
        <div class="hint">直近6ヶ月の「何月に何件出庫したか」をSKUごとに表示（折りたたみ）</div>
      </div>

      <div class="row actions">
        <div class="field" style="min-width:320px;">
          <label>検索（SKU / 商品名）</label>
          <input id="skuOutSearch" type="text" placeholder="例: A001 / りんご" oninput="renderSkuMonthlyOutflow()" />
        </div>
        <button class="btn-ghost" onclick="document.getElementById('skuOutSearch').value=''; renderSkuMonthlyOutflow();">クリア</button>
        <span class="pill">SKU数: <b id="skuOutCount">0</b></span>
      </div>

      <div class="tableWrap" style="margin-top:10px;">
        <table id="skuOutTable" style="min-width:1180px;"></table>
      </div>

      <div class="muted" style="margin-top:10px;">
        対象種別：<code>出庫</code> と <code>CSV出庫</code>（※文字列に「出庫」を含むものを出庫として扱います）
      </div>
    </div>
  </details>

  <!-- 月次出庫集計（全体） -->
  <div class="card tableCard" style="margin-top:12px;">
    <div class="tableHeader">
      <h2>月次出庫集計（全体）</h2>
      <div class="hint">history の「出庫」系から算出</div>
    </div>
    <div class="tableWrap">
      <table id="monthlyTable"></table>
    </div>
  </div>

  <!-- 棚卸差分レポート -->
  <div class="card" style="margin-top:12px;">
    <div class="sectionTitle">
      <h2>棚卸差分レポート</h2>
      <div class="hint">直近の棚卸結果（差分が大きい順 TOP10）</div>
    </div>

    <div class="row actions" style="margin-bottom:10px;">
      <button class="btn-ghost" onclick="downloadStocktakeReportCSV()">レポートCSVをDL</button>
      <button class="btn-ghost" onclick="clearStocktakeReport()">レポートをクリア</button>
    </div>

    <div class="muted" id="stocktakeReportMeta" style="margin-bottom:10px;">
      まだ棚卸が実行されていません。
    </div>

    <div class="tableWrap" style="border:1px solid var(--line); border-radius:12px; overflow:hidden;">
      <table id="stocktakeReportTable" style="min-width:900px;"></table>
    </div>
  </div>

  <!-- 4) 履歴フィルタ -->
  <div class="card" style="margin-top:12px;">
    <div class="sectionTitle">
      <h2>履歴フィルタ</h2>
      <div class="hint">SKU / 種別 / 期間で絞り込み</div>
    </div>

    <div class="row actions">
      <div class="field" style="min-width:220px;">
        <label>SKU（部分一致OK）</label>
        <input id="historySkuFilter" type="text" placeholder="例: A001" oninput="applyHistoryView()" />
      </div>

      <div class="field" style="min-width:240px;">
        <label>種別</label>
        <select id="historyTypeFilter" onchange="applyHistoryView()">
          <option value="">すべて</option>
          <option value="入庫">入庫</option>
          <option value="出庫">出庫</option>
          <option value="編集">編集</option>
          <option value="削除">削除</option>
          <option value="CSV">CSV</option>
          <option value="棚卸">棚卸</option>
          <option value="商品情報編集">商品情報編集</option>
          <option value="alert_qty一括設定">alert_qty一括設定</option>
        </select>
      </div>

      <div class="field" style="max-width:200px;">
        <label>開始日（JST）</label>
        <input id="historyFrom" type="date" onchange="applyHistoryView()" />
      </div>

      <div class="field" style="max-width:200px;">
        <label>終了日（JST）</label>
        <input id="historyTo" type="date" onchange="applyHistoryView()" />
      </div>

      <button class="btn-ghost" onclick="resetHistoryView()">フィルタクリア</button>
      <span class="pill">件数: <b id="historyCountBadge">0</b></span>
    </div>

    <div class="muted" style="margin-top:8px;">
      ※「種別」は部分一致（例：CSV増減/CSV上書き/CSV出庫 は “CSV” を選ぶとヒット）
    </div>
  </div>

  <!-- 履歴テーブル -->
  <div class="card tableCard" style="margin-top:12px; margin-bottom:12px;">
    <div class="tableHeader">
      <h2>入出庫履歴</h2>
      <div class="hint">東京時間（JST） / 最新が上</div>
    </div>
    <div class="tableWrap">
      <table id="historyTable"></table>
    </div>
  </div>

  <!-- バックアップ（ページ下・折りたたみ） -->
  <details style="margin-top:12px; margin-bottom:18px;">
    <summary>バックアップ（慣れてる人用）</summary>
    <div class="card" style="margin-top:10px; box-shadow:none;">
      <div class="sectionTitle">
        <h2>バックアップ</h2>
        <div class="hint">手動DL / 自動は「このページが開いている間だけ」</div>
      </div>

      <div class="row actions" style="margin-bottom:10px;">
        <button class="btn-ghost" onclick="exportStocksCSV()">在庫CSV（詳細）</button>
        <button class="btn-ghost" onclick="exportSkuQtyCSV()">在庫数CSV（sku,qty）</button>
        <button class="btn-ghost" onclick="exportHistoryCSV()">履歴CSV</button>
        <button class="btn-primary" onclick="exportLowStockCSV()">不足CSV（qty &lt; alert）</button>
      </div>

      <div class="row actions" style="margin-top:10px;">
        <div class="field" style="max-width:240px;">
          <label>自動バックアップ間隔（分）</label>
          <input id="autoBackupMinutes" type="number" placeholder="例：60" value="0" />
        </div>
        <button class="btn-ghost" onclick="toggleAutoBackup()">自動バックアップON/OFF</button>
        <span class="pill">状態: <b id="autoBackupBadge">OFF</b></span>
      </div>

      <div class="muted" style="margin-top:10px; line-height:1.6;">
        ※自動バックアップは、指定間隔で <code>stocks_YYYYMMDD.csv</code> と <code>history_YYYYMMDD.csv</code> を自動DLします。<br>
        ※PC側のダウンロード設定によっては確認ダイアログが出る場合あり。
      </div>

      <details style="margin-top:12px;">
        <summary>本当の自動バックアップ（Supabase側で毎日）</summary>
        <div class="muted" style="margin-top:10px; line-height:1.7;">
          これは「ページを開いてなくても動く」やつ。<br>
          ・Supabase の <b>Edge Function</b> で stocks/history を Storage に書き出す<br>
          ・Supabase の <b>Scheduled Triggers（cron）</b> で毎日実行<br>
          必要なら、あなたのSupabase構成に合わせて “コピペ手順” も出せます。
        </div>
      </details>
    </div>
  </details>

</div>

<script>
/* ========= Supabase ========= */
const SUPABASE_URL = "https://dabhwrkugxxbkvwlcyxi.supabase.co";
const SUPABASE_ANON_KEY =
  "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRhYmh3cmt1Z3h4Ymt2d2xjeXhpIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjczMjAwNjksImV4cCI6MjA4Mjg5NjA2OX0.G60_QQy0SOY7w-72Mq-gMoq99kUPj1I6c13G2SxOHeQ";
const supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

/* ✅ 運用PIN（空文字ならPINなし） */
const EDIT_PIN = "1234";

/* 既定アラート閾値（SKU別にalert_qtyで上書き可） */
const DEFAULT_ALERT_QTY = 3;

/* キャッシュ */
window.__stocks_cache__ = [];
window.__history_cache__ = [];
window.__stocktake_report__ = { meta: null, rows: [] };

/* auto backup */
window.__auto_backup_timer__ = null;

/* 出庫集計キャッシュ */
window.__outflow_by_sku_month__ = new Map(); // sku -> Map(ym -> total)
window.__outflow_month_keys_3__ = [];
window.__outflow_month_keys_6__ = [];
window.__outflow_total_3__ = new Map(); // sku -> total(3m)

/* 発注アシスト */
window.__order_rows__ = []; // {sku,name,qty,alert_qty,shortage,order_qty}

/* ========= helpers ========= */
function setStatus(msg, ok=true) {
  const el = document.getElementById("status");
  el.textContent = "状態: " + msg;
  el.className = ok ? "good" : "bad";
}
function showErr(context, err) {
  console.error(context, err);
  const detail = err ? (err.message || JSON.stringify(err)) : "unknown";
  alert(`${context}\n\n${detail}`);
  setStatus(`${context} → ${detail}`, false);
}
function currentUser() {
  return (document.getElementById("userInput").value || "未入力").trim() || "未入力";
}
function getAlertQtyForRow(row){
  const v = row?.alert_qty;
  const n = Number(v);
  if (Number.isFinite(n) && n >= 0) return n;
  return DEFAULT_ALERT_QTY;
}
function shortageForRow(row){
  const qty = Number(row?.qty || 0);
  const alertQty = getAlertQtyForRow(row);
  return Math.max(0, alertQty - qty);
}
function isLowForRow(row){
  // 不足判定（不足CSV/不足表示）は qty < alert
  return Number(row?.qty || 0) < getAlertQtyForRow(row);
}
function normalizeAlertInput(raw){
  const s = String(raw ?? "").trim();
  if (s === "") return null;
  const n = Number(s);
  if (!Number.isFinite(n) || n < 0) return { error: "アラート閾値は0以上の数字で入力してください（空欄＝既定）" };
  return n;
}
function getHighlightMode(){
  return document.getElementById("highlightMode").value; // le or lt
}

/* ========= JST month keys ========= */
function monthKeyJST(dateIsoOrDate){
  const d = (dateIsoOrDate instanceof Date) ? dateIsoOrDate : new Date(dateIsoOrDate);
  const parts = new Intl.DateTimeFormat("ja-JP", { timeZone: "Asia/Tokyo", year:"numeric", month:"2-digit" }).formatToParts(d);
  const y = parts.find(p=>p.type==="year")?.value || "";
  const m = parts.find(p=>p.type==="month")?.value || "";
  return `${y}-${m}`; // YYYY-MM
}
function lastNMonthKeys(n){
  // JST 기준 "今月" を含めて n 個
  const now = new Date();
  // JSTの年月を安全に扱うため、JST相当の「月初12:00」を作る
  const nowJstY = Number(new Intl.DateTimeFormat("ja-JP", { timeZone:"Asia/Tokyo", year:"numeric" }).format(now));
  const nowJstM = Number(new Intl.DateTimeFormat("ja-JP", { timeZone:"Asia/Tokyo", month:"numeric" }).format(now));
  const base = new Date(`${String(nowJstY).padStart(4,"0")}-${String(nowJstM).padStart(2,"0")}-01T12:00:00+09:00`);
  const keys = [];
  for (let i=n-1; i>=0; i--){
    const d = new Date(base);
    d.setMonth(d.getMonth() - i);
    keys.push(monthKeyJST(d));
  }
  return keys;
}
function monthLabel(ym){
  // "YYYY-MM" -> "MM月"
  const m = ym.split("-")[1] || "";
  return `${String(Number(m))}月`;
}

/* ========= PIN 記憶 ========= */
function loadSavedPin() {
  const saved = localStorage.getItem("inv_pin") || "";
  document.getElementById("pinInput").value = saved;
}
function savePinOnChange() {
  const el = document.getElementById("pinInput");
  el.addEventListener("input", () => localStorage.setItem("inv_pin", el.value));
}
function clearSavedPin(){
  localStorage.removeItem("inv_pin");
  document.getElementById("pinInput").value = "";
  setStatus("PINをクリアしました（閲覧のみ）", true);
}
function checkPin() {
  if (!EDIT_PIN) return true;
  const entered = (document.getElementById("pinInput").value || "").trim();
  if (entered !== EDIT_PIN) {
    alert("PINが違います（操作できません）");
    return false;
  }
  return true;
}

/* ========= Load ========= */
window.onload = async () => {
  document.getElementById("alertBadge").textContent = String(DEFAULT_ALERT_QTY);
  document.getElementById("alertLabel").textContent = String(DEFAULT_ALERT_QTY);

  // shipMonth default: current month
  const now = new Date();
  const ym = monthKeyJST(now);
  const shipMonth = document.getElementById("shipMonth");
  if (shipMonth) shipMonth.value = ym;

  loadSavedPin();
  savePinOnChange();
  setStatus("読み込み中…");
  await loadAll();
};

async function loadAll() {
  setStatus("読み込み中…");

  const s = await supabaseClient.from("stocks").select("*").order("sku");
  if (s.error) return showErr("stocks 読み込み失敗", s.error);

  // historyは多くなるので必要なら期間取得へ変更可（まずは現状維持）
  const h = await supabaseClient.from("history").select("*").order("date", { ascending: false });
  if (h.error) return showErr("history 読み込み失敗", h.error);

  window.__stocks_cache__ = (s.data || []);
  window.__history_cache__ = (h.data || []);

  computeOutflowCaches(); // 出庫集計（3ヶ月/6ヶ月）
  applyStockView();       // 検索 + 不足表示
  applyHistoryView();     // 履歴フィルタ
  renderMonthly(window.__history_cache__);
  renderSkuMonthlyOutflow();
  renderStocktakeReport();
  renderOrderAssistTable(); // 発注アシスト（必要なら）

  setStatus("準備OK", true);
}

/* ========= 出庫集計 ========= */
function isOutflowType(typeStr){
  const t = String(typeStr || "");
  // 「出庫」を含むものを出庫扱い（入庫は除外）
  return t.includes("出庫");
}
function computeOutflowCaches(){
  const hist = window.__history_cache__ || [];
  const keys3 = lastNMonthKeys(3);
  const keys6 = lastNMonthKeys(6);
  window.__outflow_month_keys_3__ = keys3;
  window.__outflow_month_keys_6__ = keys6;

  document.getElementById("out3Label").textContent = keys3.map(k=>monthLabel(k)).join(" / ");

  const bySku = new Map(); // sku -> Map(ym -> total)
  for (const r of hist){
    if (!isOutflowType(r.type)) continue;
    const sku = String(r.sku || "").trim();
    if (!sku) continue;
    const ym = monthKeyJST(r.date);
    const q = Number(r.qty || 0);
    if (!Number.isFinite(q)) continue;

    if (!bySku.has(sku)) bySku.set(sku, new Map());
    const m = bySku.get(sku);
    m.set(ym, (m.get(ym) || 0) + q);
  }

  window.__outflow_by_sku_month__ = bySku;

  const total3 = new Map();
  for (const [sku, m] of bySku.entries()){
    let t = 0;
    for (const k of keys3){
      t += (m.get(k) || 0);
    }
    total3.set(sku, t);
  }
  window.__outflow_total_3__ = total3;
}

/* ========= 1) 検索 / 2) 表示モード ========= */
function resetStockView(){
  document.getElementById("stockSearch").value = "";
  document.getElementById("stockViewMode").value = "all";
  document.getElementById("highlightMode").value = "le";
  applyStockView();
}

function applyStockView(){
  const q = (document.getElementById("stockSearch").value || "").trim().toLowerCase();
  const mode = document.getElementById("stockViewMode").value; // all / low

  let list = [...window.__stocks_cache__];

  if (q){
    list = list.filter(r => {
      const sku = String(r.sku || "").toLowerCase();
      const name = String(r.name || "").toLowerCase();
      return sku.includes(q) || name.includes(q);
    });
  }

  if (mode === "low"){
    list = list.filter(r => isLowForRow(r)); // qty < alert
    document.getElementById("viewBadge").textContent = "不足のみ";
  } else {
    document.getElementById("viewBadge").textContent = "全件";
  }

  renderStocks(list);
}

/* ========= render stocks ========= */
function renderStocks(stocks) {
  const table = document.getElementById("stockTable");
  table.innerHTML = `
    <tr>
      <th style="width:170px;">SKU</th>
      <th style="min-width:340px;">商品</th>
      <th style="width:220px; text-align:right;">数量（直近3ヶ月 出庫）</th>
      <th style="width:120px; text-align:right;">アラート</th>
      <th style="width:80px; text-align:right;">差</th>
      <th style="width:560px;">操作</th>
    </tr>`;

  if (!stocks.length){
    const tr = table.insertRow();
    tr.innerHTML = `<td colspan="6" class="center muted">該当する在庫がありません</td>`;
    return;
  }

  const hl = getHighlightMode(); // le/lt
  const keys3 = window.__outflow_month_keys_3__ || [];
  const outBySku = window.__outflow_by_sku_month__ || new Map();

  stocks.forEach(s => {
    const qty = Number(s.qty || 0);
    const alertQty = getAlertQtyForRow(s);
    const shortage = shortageForRow(s);

    const tr = table.insertRow();
    const shouldHighlight = (hl === "le") ? (qty <= alertQty) : (qty < alertQty);
    if (shouldHighlight) tr.classList.add("low-stock");

    const alertLabel = (s.alert_qty === null || s.alert_qty === undefined || s.alert_qty === "") ? `既定(${DEFAULT_ALERT_QTY})` : String(alertQty);

    // 出庫（月別・直近3ヶ月）バッジ（案A）
    const sku = String(s.sku || "");
    const m = outBySku.get(sku) || new Map();
    const badges = keys3.map(k => {
      const v = m.get(k) || 0;
      return `<span class="badge">${escapeHtml(monthLabel(k))}: <b>${Number(v)}</b></span>`;
    }).join("");

    tr.innerHTML = `
      <td class="muted">${escapeHtml(s.sku || "")}</td>
      <td class="nameCell">${escapeHtml(s.name || "")}</td>
      <td class="qty">
        ${qty}
        <div class="badgeGroup">${badges}</div>
      </td>
      <td class="qty">${escapeHtml(alertLabel)}</td>
      <td class="qty">${shortage}</td>
      <td>
        <button class="btn-ghost btn-small" onclick="restockItemQty('${escapeJs(s.sku||"")}', '${escapeJs(s.name||"")}')">数量入庫</button>
        <button class="btn-primary btn-small" onclick="shipItemQty('${escapeJs(s.sku||"")}', '${escapeJs(s.name||"")}')">数量出庫</button>
        <button class="btn-ghost btn-small" onclick="shipItem('${escapeJs(s.sku||"")}', '${escapeJs(s.name||"")}')">出庫(-1)</button>
        <button class="btn-ghost btn-small" onclick="editItemInfo('${escapeJs(s.sku||"")}', '${escapeJs(s.name||"")}')">SKU/商品名/アラート編集</button>
        <button class="btn-ghost btn-small" onclick="editQty('${escapeJs(s.sku||"")}', '${escapeJs(s.name||"")}', ${qty})">在庫編集</button>
        <button class="btn-danger btn-small" onclick="deleteItem('${escapeJs(s.sku||"")}', '${escapeJs(s.name||"")}')">削除</button>
      </td>
    `;
  });
}

/* ========= SKU別 直近6ヶ月（月別） ========= */
function renderSkuMonthlyOutflow(){
  const table = document.getElementById("skuOutTable");
  const countEl = document.getElementById("skuOutCount");
  if (!table || !countEl) return;

  const keys6 = window.__outflow_month_keys_6__ || [];
  const outBySku = window.__outflow_by_sku_month__ || new Map();
  const stocks = window.__stocks_cache__ || [];

  const nameBySku = new Map(stocks.map(s => [String(s.sku||""), String(s.name||"")]));
  const allSkus = new Set();
  for (const s of stocks) if (s.sku) allSkus.add(String(s.sku));
  for (const sku of outBySku.keys()) allSkus.add(String(sku));

  const q = (document.getElementById("skuOutSearch").value || "").trim().toLowerCase();

  // rows
  const rows = [];
  for (const sku of allSkus){
    const name = nameBySku.get(sku) || "";
    if (q){
      if (!sku.toLowerCase().includes(q) && !name.toLowerCase().includes(q)) continue;
    }
    const m = outBySku.get(sku) || new Map();
    let total = 0;
    const vals = keys6.map(k => {
      const v = m.get(k) || 0;
      total += v;
      return v;
    });
    rows.push({ sku, name, vals, total });
  }

  // sort: total desc
  rows.sort((a,b) => (b.total - a.total) || a.sku.localeCompare(b.sku));

  countEl.textContent = String(rows.length);

  // header
  const thMonths = keys6.map(k => `<th style="width:110px; text-align:right;">${escapeHtml(monthLabel(k))}</th>`).join("");
  table.innerHTML = `
    <tr>
      <th style="width:170px;">SKU</th>
      <th style="min-width:340px;">商品</th>
      ${thMonths}
      <th style="width:120px; text-align:right;">合計</th>
    </tr>
  `;

  if (!rows.length){
    const tr = table.insertRow();
    tr.innerHTML = `<td colspan="${3 + keys6.length}" class="center muted">該当するSKUがありません</td>`;
    return;
  }

  for (const r of rows){
    const tr = table.insertRow();
    const tds = r.vals.map(v => `<td class="qty">${Number(v)}</td>`).join("");
    tr.innerHTML = `
      <td class="muted">${escapeHtml(r.sku)}</td>
      <td class="nameCell">${escapeHtml(r.name)}</td>
      ${tds}
      <td class="qty">${Number(r.total)}</td>
    `;
  }
}

/* ========= render history (filtered later) ========= */
function renderHistory(history) {
  const table = document.getElementById("historyTable");
  table.innerHTML = `
    <tr>
      <th style="width:190px;">日時（JST）</th>
      <th style="width:120px;">ユーザー</th>
      <th style="width:200px;">種別</th>
      <th style="width:160px;">SKU</th>
      <th>商品</th>
      <th style="width:110px; text-align:right;">数量</th>
    </tr>`;

  if (!history.length){
    const tr = table.insertRow();
    tr.innerHTML = `<td colspan="6" class="center muted">該当する履歴がありません</td>`;
    return;
  }

  history.forEach(h => {
    const tr = table.insertRow();
    tr.innerHTML = `
      <td class="muted">${escapeHtml(formatDate(h.date))}</td>
      <td>${escapeHtml(h.user)}</td>
      <td>${escapeHtml(h.type)}</td>
      <td class="muted">${escapeHtml(h.sku || "")}</td>
      <td class="nameCell">${escapeHtml(h.name || "")}</td>
      <td class="qty">${escapeHtml(String(h.qty))}</td>
    `;
  });
}

/* ========= 月次出庫（全体） ========= */
function renderMonthly(history) {
  const table = document.getElementById("monthlyTable");
  const map = {};
  history.filter(h => isOutflowType(h.type)).forEach(h => {
    const ym = monthKeyJST(h.date); // JST基準
    map[ym] = (map[ym] || 0) + Number(h.qty || 0);
  });

  table.innerHTML = `
    <tr>
      <th style="width:160px;">月</th>
      <th style="width:140px; text-align:right;">出庫数</th>
    </tr>`;

  const keys = Object.keys(map).sort();
  if (!keys.length) {
    table.insertRow().innerHTML = `<td colspan="2" class="center muted">まだ出庫履歴がありません</td>`;
    return;
  }
  keys.forEach(ym => {
    const tr = table.insertRow();
    tr.innerHTML = `<td>${escapeHtml(ym)}</td><td class="qty">${map[ym]}</td>`;
  });
}

/* ========= 4) 履歴フィルタ ========= */
function resetHistoryView(){
  document.getElementById("historySkuFilter").value = "";
  document.getElementById("historyTypeFilter").value = "";
  document.getElementById("historyFrom").value = "";
  document.getElementById("historyTo").value = "";
  applyHistoryView();
}

function applyHistoryView(){
  const skuQ = (document.getElementById("historySkuFilter").value || "").trim().toLowerCase();
  const typeQ = (document.getElementById("historyTypeFilter").value || "").trim(); // 部分一致
  const from = document.getElementById("historyFrom").value; // YYYY-MM-DD
  const to = document.getElementById("historyTo").value;     // YYYY-MM-DD

  let list = [...window.__history_cache__];

  if (skuQ){
    list = list.filter(r => String(r.sku || "").toLowerCase().includes(skuQ));
  }
  if (typeQ){
    list = list.filter(r => String(r.type || "").includes(typeQ));
  }
  if (from){
    const fromTs = new Date(from + "T00:00:00+09:00").getTime();
    list = list.filter(r => new Date(r.date).getTime() >= fromTs);
  }
  if (to){
    // to の 23:59:59 JST まで
    const toTs = new Date(to + "T23:59:59+09:00").getTime();
    list = list.filter(r => new Date(r.date).getTime() <= toTs);
  }

  document.getElementById("historyCountBadge").textContent = String(list.length);
  renderHistory(list);
}

/* ========= 5) auto backup (page-open only) ========= */
function toggleAutoBackup(){
  const badge = document.getElementById("autoBackupBadge");

  if (window.__auto_backup_timer__){
    clearInterval(window.__auto_backup_timer__);
    window.__auto_backup_timer__ = null;
    badge.textContent = "OFF";
    setStatus("自動バックアップを停止しました", true);
    return;
  }

  const mins = Number(document.getElementById("autoBackupMinutes").value);
  if (!Number.isFinite(mins) || mins <= 0){
    alert("自動バックアップ間隔（分）を 1 以上で入力してください（例：60）");
    return;
  }

  const ms = mins * 60 * 1000;
  window.__auto_backup_timer__ = setInterval(async () => {
    try{
      await exportStocksCSV(true);
      await exportHistoryCSV(true);
      setStatus(`自動バックアップ実行（${mins}分ごと）`, true);
    }catch(e){
      console.error(e);
      setStatus("自動バックアップ中にエラー", false);
    }
  }, ms);

  badge.textContent = `ON（${mins}分）`;
  setStatus(`自動バックアップON（${mins}分ごと）`, true);
}

/* ========= 一括：alert_qty 未設定を既定値へ ========= */
async function bulkFillAlertQty(){
  if (!checkPin()) return;

  const ok = confirm(`alert_qty が未設定のSKUに、既定値(${DEFAULT_ALERT_QTY})を一括設定します。OK？`);
  if (!ok) return;

  setStatus("一括更新中…", true);

  const r = await supabaseClient
    .from("stocks")
    .update({ alert_qty: DEFAULT_ALERT_QTY })
    .is("alert_qty", null);

  if (r.error) return showErr("alert_qty 一括更新失敗", r.error);

  const hin = await supabaseClient.from("history").insert({
    date: new Date().toISOString(),
    user: currentUser(),
    type: "alert_qty一括設定",
    sku: null,
    name: "",
    qty: 0
  });
  if (hin.error) return showErr("history insert 失敗", hin.error);

  await loadAll();
  alert("未設定のalert_qtyを既定値にしました");
}

/* ========= 照合 ========= */
async function findStockRow(sku, name) {
  if (sku) return await supabaseClient.from("stocks").select("*").eq("sku", sku).maybeSingle();
  return await supabaseClient.from("stocks").select("*").eq("name", name).maybeSingle();
}

/* ========= 入庫/出庫 ========= */
async function addItemManual() {
  if (!checkPin()) return;

  const sku = (document.getElementById("skuInput").value || "").trim();
  const name = (document.getElementById("nameInput").value || "").trim();
  const qty = Number(document.getElementById("qtyInput").value);
  const alertRaw = document.getElementById("alertInput").value;

  if (!sku || !qty) return alert("SKUと数量は必須です");

  const alertVal = normalizeAlertInput(alertRaw);
  if (alertVal && alertVal.error) return alert(alertVal.error);

  const ex = await findStockRow(sku, name);
  if (ex.error) return showErr("stocks 既存チェック失敗", ex.error);

  if (ex.data) {
    const newQty = Number(ex.data.qty || 0) + qty;
    const payload = { qty: newQty };
    if (name) payload.name = name;
    if (alertVal !== null) payload.alert_qty = alertVal;
    const up = await supabaseClient.from("stocks").update(payload).eq("id", ex.data.id);
    if (up.error) return showErr("stocks update 失敗", up.error);
  } else {
    const payload = { sku, name: name || "", qty };
    if (alertVal !== null) payload.alert_qty = alertVal;
    const ins = await supabaseClient.from("stocks").insert(payload);
    if (ins.error) return showErr("stocks insert 失敗", ins.error);
  }

  const hin = await supabaseClient.from("history").insert({
    date: new Date().toISOString(),
    user: currentUser(),
    type: "入庫",
    sku,
    name: name || "",
    qty
  });
  if (hin.error) return showErr("history insert 失敗", hin.error);

  document.getElementById("skuInput").value = "";
  document.getElementById("nameInput").value = "";
  document.getElementById("qtyInput").value = "";
  document.getElementById("alertInput").value = "";

  await loadAll();
}

async function restockItemQty(sku, name){
  if (!checkPin()) return;

  const ex = await findStockRow(sku, name);
  if (ex.error) return showErr("stocks 取得失敗", ex.error);
  if (!ex.data) return;

  const current = Number(ex.data.qty || 0);
  const input = prompt(
    `数量入庫（SKU: ${sku} / 商品: ${ex.data.name || ""}）\n現在: ${current}\n入庫数量（1以上）`,
    "1"
  );
  if (input === null) return;

  const n = Number(input);
  if (!Number.isFinite(n) || n <= 0) return alert("1以上の数字を入力してください");

  const up = await supabaseClient.from("stocks").update({ qty: current + n }).eq("id", ex.data.id);
  if (up.error) return showErr("stocks update 失敗", up.error);

  const hin = await supabaseClient.from("history").insert({
    date: new Date().toISOString(),
    user: currentUser(),
    type: "入庫",
    sku: ex.data.sku || sku,
    name: ex.data.name || "",
    qty: n
  });
  if (hin.error) return showErr("history insert 失敗", hin.error);

  await loadAll();
}

async function shipItem(sku, name) {
  if (!checkPin()) return;

  const ex = await findStockRow(sku, name);
  if (ex.error) return showErr("stocks 取得失敗", ex.error);
  if (!ex.data) return;

  const newQty = Number(ex.data.qty) - 1;

  if (newQty <= 0) {
    const del = await supabaseClient.from("stocks").delete().eq("id", ex.data.id);
    if (del.error) return showErr("stocks delete 失敗", del.error);
  } else {
    const up = await supabaseClient.from("stocks").update({ qty: newQty }).eq("id", ex.data.id);
    if (up.error) return showErr("stocks update 失敗", up.error);
  }

  const hin = await supabaseClient.from("history").insert({
    date: new Date().toISOString(),
    user: currentUser(),
    type: "出庫",
    sku: ex.data.sku || sku,
    name: ex.data.name || "",
    qty: 1
  });
  if (hin.error) return showErr("history insert 失敗", hin.error);

  await loadAll();
}

async function shipItemQty(sku, name) {
  if (!checkPin()) return;

  const ex = await findStockRow(sku, name);
  if (ex.error) return showErr("stocks 取得失敗", ex.error);
  if (!ex.data) return;

  const current = Number(ex.data.qty || 0);
  const input = prompt(
    `数量出庫（SKU: ${sku} / 商品: ${ex.data.name || ""}）\n現在: ${current}\n出庫数量（1以上）`,
    "1"
  );
  if (input === null) return;

  const n = Number(input);
  if (!Number.isFinite(n) || n <= 0) return alert("1以上の数字を入力してください");

  const newQty = current - n;

  if (newQty <= 0) {
    const del = await supabaseClient.from("stocks").delete().eq("id", ex.data.id);
    if (del.error) return showErr("stocks delete 失敗", del.error);
  } else {
    const up = await supabaseClient.from("stocks").update({ qty: newQty }).eq("id", ex.data.id);
    if (up.error) return showErr("stocks update 失敗", up.error);
  }

  const hin = await supabaseClient.from("history").insert({
    date: new Date().toISOString(),
    user: currentUser(),
    type: "出庫",
    sku: ex.data.sku || sku,
    name: ex.data.name || "",
    qty: n
  });
  if (hin.error) return showErr("history insert 失敗", hin.error);

  await loadAll();
}

/* ========= SKU/商品名/アラート 編集 ========= */
async function editItemInfo(oldSku, oldName) {
  if (!checkPin()) return;

  const ex = await findStockRow(oldSku, oldName);
  if (ex.error) return showErr("stocks 取得失敗", ex.error);
  if (!ex.data) return alert("商品が見つかりません");

  const curSku = (ex.data.sku || "").trim();
  const curName = (ex.data.name || "").trim();
  const curAlert = (ex.data.alert_qty === null || ex.data.alert_qty === undefined) ? "" : String(ex.data.alert_qty);

  const newSku = prompt(`SKUを編集（必須）\n現在: ${curSku}`, curSku);
  if (newSku === null) return;
  if (!newSku.trim()) return alert("SKUは必須です");

  const newName = prompt(`商品名を編集（任意）\n現在: ${curName}`, curName);
  if (newName === null) return;

  const newAlertRaw = prompt(
    `アラート閾値を編集（任意）\n空欄＝既定(${DEFAULT_ALERT_QTY})\n現在: ${curAlert === "" ? "（既定）" : curAlert}`,
    curAlert
  );
  if (newAlertRaw === null) return;

  const alertVal = normalizeAlertInput(newAlertRaw);
  if (alertVal && alertVal.error) return alert(alertVal.error);

  const dup = await supabaseClient.from("stocks").select("id").eq("sku", newSku.trim()).maybeSingle();
  if (dup.error) return showErr("SKU重複チェック失敗", dup.error);
  if (dup.data && dup.data.id !== ex.data.id) return alert(`SKU「${newSku.trim()}」は既に存在します。別のSKUにしてください。`);

  const payload = { sku: newSku.trim(), name: (newName || "").trim(), alert_qty: (alertVal === null) ? null : alertVal };
  const up = await supabaseClient.from("stocks").update(payload).eq("id", ex.data.id);
  if (up.error) return showErr("stocks update 失敗", up.error);

  const hin = await supabaseClient.from("history").insert({
    date: new Date().toISOString(),
    user: currentUser(),
    type: "商品情報編集",
    sku: payload.sku,
    name: payload.name,
    qty: 0
  });
  if (hin.error) return showErr("history insert 失敗", hin.error);

  await loadAll();
}

/* ========= 在庫編集 ========= */
async function editQty(sku, name, currentQty) {
  if (!checkPin()) return;

  const input = prompt(`在庫数を変更（SKU: ${sku} / 商品: ${name||""}）\n現在: ${currentQty}\n新しい数量`, String(currentQty));
  if (input === null) return;

  const newQty = Number(input);
  if (!Number.isFinite(newQty) || newQty < 0) return alert("0以上の数字を入力してください");

  const ex = await findStockRow(sku, name);
  if (ex.error) return showErr("stocks 取得失敗", ex.error);
  if (!ex.data) return alert("商品が見つかりません");

  if (newQty === 0) {
    const del = await supabaseClient.from("stocks").delete().eq("id", ex.data.id);
    if (del.error) return showErr("stocks delete 失敗", del.error);
  } else {
    const up = await supabaseClient.from("stocks").update({ qty: newQty }).eq("id", ex.data.id);
    if (up.error) return showErr("stocks update 失敗", up.error);
  }

  const diff = newQty - Number(ex.data.qty);
  const type = diff >= 0 ? "編集（増）" : "編集（減）";

  const hin = await supabaseClient.from("history").insert({
    date: new Date().toISOString(),
    user: currentUser(),
    type,
    sku: ex.data.sku || sku,
    name: ex.data.name || "",
    qty: Math.abs(diff)
  });
  if (hin.error) return showErr("history insert 失敗", hin.error);

  await loadAll();
}

/* ========= 削除（確認2回） ========= */
async function deleteItem(sku, name) {
  if (!checkPin()) return;

  if (!confirm("ほんまにええんか？")) return;
  if (!confirm("ほんまに削除してええんか？")) return;

  const ex = await findStockRow(sku, name);
  if (ex.error) return showErr("stocks 取得失敗", ex.error);
  if (!ex.data) return;

  const del = await supabaseClient.from("stocks").delete().eq("id", ex.data.id);
  if (del.error) return showErr("stocks delete 失敗", del.error);

  const hin = await supabaseClient.from("history").insert({
    date: new Date().toISOString(),
    user: currentUser(),
    type: "削除",
    sku: ex.data.sku || sku,
    name: ex.data.name || "",
    qty: 0
  });
  if (hin.error) return showErr("history insert 失敗", hin.error);

  await loadAll();
}

/* ========= CSV Export ========= */
function downloadText(filename, text) {
  const blob = new Blob([text], { type: "text/csv;charset=utf-8" });
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  a.click();
}
function todayStr() {
  const d = new Date();
  return `${d.getFullYear()}${String(d.getMonth()+1).padStart(2,"0")}${String(d.getDate()).padStart(2,"0")}`;
}
function csvEscape(v) {
  const s = String(v ?? "");
  if (/[",\n\r]/.test(s)) return `"${s.replace(/"/g,'""')}"`;
  return s;
}

/* 在庫CSV（詳細） */
async function exportStocksCSV(silent=false) {
  const s = await supabaseClient.from("stocks").select("*").order("sku");
  if (s.error) return showErr("在庫CSV取得失敗", s.error);

  let csv = "sku,name,qty,alert_qty,shortage\n";
  (s.data || []).forEach(r => {
    const aq = (r.alert_qty === null || r.alert_qty === undefined) ? "" : String(r.alert_qty);
    const alertNum = (aq === "") ? DEFAULT_ALERT_QTY : Number(aq);
    const sh = Math.max(0, alertNum - Number(r.qty || 0));
    csv += `${csvEscape(r.sku||"")},${csvEscape(r.name||"")},${Number(r.qty||0)},${csvEscape(aq)},${sh}\n`;
  });
  downloadText(`stocks_${todayStr()}.csv`, csv);
  if (!silent) alert("在庫CSVを出力しました");
}

/* 在庫数CSV（sku,qty） */
async function exportSkuQtyCSV(){
  const s = await supabaseClient.from("stocks").select("sku,qty").order("sku");
  if (s.error) return showErr("在庫数CSV取得失敗", s.error);

  let csv = "sku,qty\n";
  (s.data || []).forEach(r => {
    csv += `${csvEscape(r.sku||"")},${Number(r.qty||0)}\n`;
  });
  downloadText(`sku_qty_${todayStr()}.csv`, csv);
  alert("在庫数CSVを出力しました");
}

/* 不足CSV：qty < alert */
function exportLowStockCSV(){
  const stocks = window.__stocks_cache__ || [];
  const low = stocks
    .map(r => ({...r, _alert: getAlertQtyForRow(r), _short: shortageForRow(r)}))
    .filter(r => Number(r.qty || 0) < r._alert);

  let csv = "sku,name,qty,alert_qty,shortage\n";
  low.forEach(r => {
    const aq = (r.alert_qty === null || r.alert_qty === undefined) ? "" : String(r.alert_qty);
    csv += `${csvEscape(r.sku||"")},${csvEscape(r.name||"")},${Number(r.qty || 0)},${csvEscape(aq)},${Number(r._short)}\n`;
  });

  downloadText(`low_stock_${todayStr()}.csv`, csv);
  alert(`不足CSVを出力しました（${low.length}件）`);
}

/* 履歴CSV */
async function exportHistoryCSV(silent=false) {
  const h = await supabaseClient.from("history").select("*").order("date", { ascending: false });
  if (h.error) return showErr("履歴CSV取得失敗", h.error);

  let csv = "date,user,type,sku,name,qty\n";
  (h.data || []).forEach(r => {
    csv += `${csvEscape(r.date)},${csvEscape(r.user)},${csvEscape(r.type)},${csvEscape(r.sku||"")},${csvEscape(r.name||"")},${csvEscape(String(r.qty))}\n`;
  });
  downloadText(`history_${todayStr()}.csv`, csv);
  if (!silent) alert("履歴CSVを出力しました");
}

/* ========= CSV parsing ========= */
function parseCSV(text) {
  const rows = [];
  let row = [];
  let cur = "";
  let inQ = false;

  for (let i=0; i<text.length; i++) {
    const ch = text[i], next = text[i+1];
    if (ch === '"') {
      if (inQ && next === '"') { cur += '"'; i++; }
      else inQ = !inQ;
      continue;
    }
    if (!inQ && ch === ",") { row.push(cur); cur=""; continue; }
    if (!inQ && (ch === "\n" || ch === "\r")) {
      if (ch === "\r" && next === "\n") i++;
      row.push(cur); rows.push(row);
      row=[]; cur=""; continue;
    }
    cur += ch;
  }
  if (cur.length || row.length) { row.push(cur); rows.push(row); }
  return rows;
}

/* ========= 在庫CSVインポート（増減/上書き） ========= */
async function importStocksCSV(inputEl) {
  if (!checkPin()) { inputEl.value = ""; return; }
  const file = inputEl.files?.[0];
  if (!file) return;

  setStatus("CSV読み込み中…", true);

  const text = await file.text();
  const rows = parseCSV(text).map(r => r.map(c => (c ?? "").trim())).filter(r => r.length >= 2);
  if (!rows.length) { alert("CSVが空です"); inputEl.value = ""; return; }

  let countProcessed = 0, countUpdated = 0, countInserted = 0, countDeleted = 0, countSkipped = 0;
  const errors = [];
  const pushError = (line, msg) => errors.push(`行${line}: ${msg}`);

  const header = rows[0].map(x => x.toLowerCase());
  const hasHeader = header.includes("name") || header.includes("sku") || header.includes("qty") || header.includes("delta") || header.includes("alert_qty");

  let dataRows = rows;
  let mode = "set";
  let idxSku = 0, idxName = 1, idxValue = 2, idxAlert = -1;

  if (hasHeader) {
    idxSku = header.indexOf("sku");
    idxName = header.indexOf("name");
    const iDelta = header.indexOf("delta");
    const iQty = header.indexOf("qty");
    idxAlert = header.indexOf("alert_qty");
    if (iDelta !== -1) { mode="delta"; idxValue = iDelta; }
    else { mode="set"; idxValue = iQty !== -1 ? iQty : 2; }
    dataRows = rows.slice(1);
  } else {
    mode = "set";
    if (rows[0].length === 2) { idxSku = -1; idxName = 0; idxValue = 1; idxAlert = -1; }
    else if (rows[0].length >= 4) { idxSku = 0; idxName = 1; idxValue = 2; idxAlert = 3; }
    else { idxSku = 0; idxName = 1; idxValue = 2; idxAlert = -1; }
  }

  const existing = await supabaseClient.from("stocks").select("*");
  if (existing.error) return showErr("既存在庫取得失敗", existing.error);

  const bySku = new Map((existing.data||[]).filter(x=>x.sku).map(x => [x.sku, x]));
  const byName = new Map((existing.data||[]).map(x => [x.name, x]));

  setStatus("CSV取り込み中…", true);

  for (let i = 0; i < dataRows.length; i++) {
    const r = dataRows[i];
    const lineNo = hasHeader ? (i + 2) : (i + 1);

    try{
      const sku = idxSku >= 0 ? (r[idxSku] || "").trim() : "";
      const name = (r[idxName] || "").trim();
      const valRaw = (r[idxValue] || "").trim();
      const alertRaw = (idxAlert >= 0) ? (r[idxAlert] || "").trim() : "";

      if (!name && !sku) { countSkipped++; continue; }

      const num = Number(valRaw);
      if (!Number.isFinite(num)) { countSkipped++; pushError(lineNo, `数量が数値ではありません（"${valRaw}"）`); continue; }

      const alertVal = normalizeAlertInput(alertRaw);
      if (alertVal && alertVal.error) { countSkipped++; pushError(lineNo, alertVal.error); continue; }

      const found = sku ? bySku.get(sku) : byName.get(name);

      if (!found) {
        const startQty = num;
        if (startQty <= 0) { countSkipped++; continue; }

        const payload = { sku: sku || null, name: name || "", qty: startQty };
        if (alertVal !== null && idxAlert >= 0) payload.alert_qty = alertVal;

        const ins = await supabaseClient.from("stocks").insert(payload);
        if (ins.error) { pushError(lineNo, `insert失敗（${sku||name}）: ${ins.error.message}`); continue; }

        countInserted++; countProcessed++;

        const hin = await supabaseClient.from("history").insert({
          date: new Date().toISOString(),
          user: currentUser(),
          type: mode === "delta" ? "CSV増減" : "CSV上書き",
          sku: payload.sku,
          name: payload.name,
          qty: Math.abs(startQty)
        });
        if (hin.error) pushError(lineNo, `history失敗: ${hin.error.message}`);
        continue;
      }

      let newQty = (mode === "delta") ? (Number(found.qty) + num) : num;

      if (newQty <= 0) {
        const del = await supabaseClient.from("stocks").delete().eq("id", found.id);
        if (del.error) { pushError(lineNo, `delete失敗（${found.sku||found.name}）: ${del.error.message}`); continue; }
        countDeleted++; countProcessed++;
        if (found.sku) bySku.delete(found.sku);
        byName.delete(found.name);
      } else {
        const payload = { qty: newQty, sku: sku || found.sku || null, name: name || found.name || "" };
        if (idxAlert >= 0 && alertVal !== null) payload.alert_qty = alertVal;

        const up = await supabaseClient.from("stocks").update(payload).eq("id", found.id);
        if (up.error) { pushError(lineNo, `update失敗（${found.sku||found.name}）: ${up.error.message}`); continue; }

        countUpdated++; countProcessed++;

        const updated = { ...found, ...payload };
        if (found.sku && updated.sku !== found.sku) bySku.delete(found.sku);
        if (updated.sku) bySku.set(updated.sku, updated);
        byName.delete(found.name);
        byName.set(updated.name, updated);
      }

      const hin = await supabaseClient.from("history").insert({
        date: new Date().toISOString(),
        user: currentUser(),
        type: mode === "delta" ? "CSV増減" : "CSV上書き",
        sku: (sku || found.sku || null),
        name: (name || found.name || ""),
        qty: Math.abs(num)
      });
      if (hin.error) pushError(lineNo, `history失敗: ${hin.error.message}`);

    }catch(e){
      countSkipped++;
      pushError(lineNo, `例外: ${e?.message || String(e)}`);
    }
  }

  inputEl.value = "";
  await loadAll();

  const summary =
`CSVインポート完了
処理: ${countProcessed}件（insert:${countInserted} / update:${countUpdated} / delete:${countDeleted}）
スキップ: ${countSkipped}件
エラー: ${errors.length}件`;

  if (errors.length) {
    const head = errors.slice(0, 20).join("\n");
    alert(summary + "\n\n--- エラー詳細（最大20件表示） ---\n" + head + (errors.length > 20 ? `\n…他 ${errors.length - 20} 件` : ""));
    setStatus(`CSV完了（エラー ${errors.length}件）`, false);
  } else {
    alert(summary);
    setStatus("CSV完了（エラーなし）", true);
  }
}

/* ========= 出庫CSV（指定月で履歴に追加） ========= */
async function importShipmentCSV(){
  if (!checkPin()) return;

  const ym = (document.getElementById("shipMonth").value || "").trim(); // YYYY-MM
  const fileEl = document.getElementById("shipCsv");
  const file = fileEl?.files?.[0];
  if (!ym) return alert("何月の出庫か（YYYY-MM）を選んでください");
  if (!file) return alert("出庫CSVファイルを選んでください");

  const ok = confirm(`出庫CSVを「${ym} の出庫」として履歴に追加します。\n（在庫数は変更しません）\nOK？`);
  if (!ok) return;

  setStatus("出庫CSVを読み込み中…", true);

  const text = await file.text();
  const rows = parseCSV(text).map(r => r.map(c => (c ?? "").trim())).filter(r => r.length >= 2);
  if (!rows.length) return alert("CSVが空です");

  const header = rows[0].map(x => x.toLowerCase());
  const hasHeader = header.includes("sku") || header.includes("qty") || header.includes("name");

  let dataRows = rows;
  let idxSku = 0, idxName = -1, idxQty = 1;

  if (hasHeader){
    idxSku = header.indexOf("sku"); if (idxSku === -1) idxSku = 0;
    idxName = header.indexOf("name"); // optional
    idxQty = header.indexOf("qty"); if (idxQty === -1) idxQty = 1;
    dataRows = rows.slice(1);
  } else {
    if (rows[0].length >= 3) { idxSku = 0; idxName = 1; idxQty = 2; }
    else { idxSku = 0; idxName = -1; idxQty = 1; }
  }

  // date: monthの15日 12:00 JST を固定（UTCへ変換して保存）
  const fixedDateIso = new Date(`${ym}-15T12:00:00+09:00`).toISOString();

  // SKU->name補完（stocksから）
  const nameBySku = new Map((window.__stocks_cache__||[]).map(s => [String(s.sku||""), String(s.name||"")]));

  const errors = [];
  const inserts = [];
  for (let i=0; i<dataRows.length; i++){
    const lineNo = hasHeader ? (i+2) : (i+1);
    const r = dataRows[i];
    const sku = String(r[idxSku] || "").trim();
    const qtyRaw = String(r[idxQty] || "").trim();
    const nameCsv = (idxName >= 0) ? String(r[idxName] || "").trim() : "";

    if (!sku){ errors.push(`行${lineNo}: skuが空です`); continue; }

    const q = Number(qtyRaw);
    if (!Number.isFinite(q) || q < 0){ errors.push(`行${lineNo}: qtyが不正（"${qtyRaw}"）`); continue; }

    // 0は無視（邪魔なら消してもOK）
    if (q === 0) continue;

    const name = nameCsv || nameBySku.get(sku) || "";

    inserts.push({
      date: fixedDateIso,
      user: currentUser(),
      type: "CSV出庫",
      sku,
      name,
      qty: q
    });
  }

  if (!inserts.length){
    alert("追加できる行がありませんでした（qty=0のみ、またはエラー）");
    if (errors.length) alert("エラー:\n" + errors.slice(0,20).join("\n"));
    return;
  }

  setStatus("履歴へ追加中…", true);

  // chunk insert
  const chunkSize = 500;
  for (let i=0; i<inserts.length; i+=chunkSize){
    const chunk = inserts.slice(i, i+chunkSize);
    const res = await supabaseClient.from("history").insert(chunk);
    if (res.error) return showErr("出庫CSV（履歴追加）失敗", res.error);
  }

  fileEl.value = "";
  await loadAll();

  const msg = `出庫CSVを追加しました：${inserts.length}件（${ym}の出庫として）\n種別: CSV出庫`;
  if (errors.length){
    alert(msg + `\n\nエラー: ${errors.length}件（最大20件表示）\n` + errors.slice(0,20).join("\n"));
    setStatus("出庫CSV完了（エラーあり）", false);
  } else {
    alert(msg);
    setStatus("出庫CSV完了", true);
  }
}

/* ========= 6) 棚卸CSV（差分レポート） ========= */
async function importStocktakeCSV(inputEl){
  if (!checkPin()) { inputEl.value = ""; return; }
  const file = inputEl.files?.[0];
  if (!file) return;

  const text = await file.text();
  const rows = parseCSV(text).map(r => r.map(c => (c ?? "").trim())).filter(r => r.length >= 2);
  if (!rows.length) { alert("CSVが空です"); inputEl.value = ""; return; }

  const header = rows[0].map(x => x.toLowerCase());
  const hasHeader = header.includes("sku") || header.includes("qty") || header.includes("name");

  let dataRows = rows;
  let idxSku = 0, idxName = -1, idxQty = 1;

  if (hasHeader){
    idxSku = header.indexOf("sku"); if (idxSku === -1) idxSku = 0;
    idxName = header.indexOf("name");
    idxQty = header.indexOf("qty"); if (idxQty === -1) idxQty = 1;
    dataRows = rows.slice(1);
  } else {
    if (rows[0].length >= 3) { idxSku = 0; idxName = 1; idxQty = 2; }
    else { idxSku = 0; idxName = -1; idxQty = 1; }
  }

  const existing = await supabaseClient.from("stocks").select("*");
  if (existing.error) return showErr("既存在庫取得失敗", existing.error);

  const bySku = new Map((existing.data||[]).filter(x=>x.sku).map(x => [x.sku, x]));

  let processed = 0, updated = 0, inserted = 0, deleted = 0, skipped = 0;
  const errors = [];
  const pushError = (line, msg) => errors.push(`行${line}: ${msg}`);

  // レポート用：差分をためる
  const diffs = [];

  setStatus("棚卸取り込み中…", true);

  for (let i=0; i<dataRows.length; i++){
    const r = dataRows[i];
    const lineNo = hasHeader ? (i + 2) : (i + 1);

    const sku = (r[idxSku] || "").trim();
    const name = (idxName >= 0 ? (r[idxName] || "").trim() : "");
    const qtyRaw = (r[idxQty] || "").trim();

    if (!sku) { skipped++; pushError(lineNo, "skuが空です"); continue; }

    const qty = Number(qtyRaw);
    if (!Number.isFinite(qty) || qty < 0){
      skipped++; pushError(lineNo, `qtyが不正（"${qtyRaw}"）`); continue;
    }

    const found = bySku.get(sku);

    if (!found){
      if (qty <= 0) { skipped++; continue; }

      const payload = { sku, name: name || "", qty };
      const ins = await supabaseClient.from("stocks").insert(payload);
      if (ins.error){ pushError(lineNo, `insert失敗: ${ins.error.message}`); continue; }

      inserted++; processed++;

      diffs.push({ sku, name: payload.name, before: 0, after: qty, diff: qty });

      const hin = await supabaseClient.from("history").insert({
        date: new Date().toISOString(),
        user: currentUser(),
        type: "棚卸（新規）",
        sku,
        name: payload.name,
        qty
      });
      if (hin.error) pushError(lineNo, `history失敗: ${hin.error.message}`);
      continue;
    }

    const before = Number(found.qty || 0);
    const after = qty;
    const newName = name ? name : (found.name || "");

    if (after === 0){
      const del = await supabaseClient.from("stocks").delete().eq("id", found.id);
      if (del.error){ pushError(lineNo, `delete失敗: ${del.error.message}`); continue; }

      deleted++; updated++; processed++;

      diffs.push({ sku, name: newName, before, after: 0, diff: (0 - before) });

      const hin = await supabaseClient.from("history").insert({
        date: new Date().toISOString(),
        user: currentUser(),
        type: "棚卸（削除）",
        sku,
        name: newName,
        qty: Math.abs(before - after)
      });
      if (hin.error) pushError(lineNo, `history失敗: ${hin.error.message}`);
      continue;
    }

    if (before === after && newName === (found.name || "")) {
      processed++;
      continue;
    }

    const upPayload = { qty: after };
    if (newName !== (found.name || "")) upPayload.name = newName;

    const up = await supabaseClient.from("stocks").update(upPayload).eq("id", found.id);
    if (up.error){ pushError(lineNo, `update失敗: ${up.error.message}`); continue; }

    updated++; processed++;

    diffs.push({ sku, name: newName, before, after, diff: (after - before) });

    const hin = await supabaseClient.from("history").insert({
      date: new Date().toISOString(),
      user: currentUser(),
      type: "棚卸",
      sku,
      name: newName,
      qty: Math.abs(before - after)
    });
    if (hin.error) pushError(lineNo, `history失敗: ${hin.error.message}`);
  }

  inputEl.value = "";
  await loadAll();

  const sorted = [...diffs].sort((a,b) => Math.abs(b.diff) - Math.abs(a.diff));
  window.__stocktake_report__ = {
    meta: {
      at: new Date().toISOString(),
      count: diffs.length,
      processed, updated, inserted, deleted, skipped,
      errors: errors.length
    },
    rows: sorted
  };
  renderStocktakeReport();

  const summary =
`棚卸CSV完了
処理: ${processed}（update:${updated} / insert:${inserted} / delete:${deleted}）
差分発生: ${diffs.length}
スキップ: ${skipped}
エラー: ${errors.length}`;

  if (errors.length){
    alert(summary + "\n\n--- エラー詳細（最大20件） ---\n" + errors.slice(0,20).join("\n"));
    setStatus(`棚卸完了（エラー ${errors.length}件）`, false);
  }else{
    alert(summary + "\n\n※差分レポート（TOP10）を表示しました");
    setStatus("棚卸完了（エラーなし）", true);
  }
}

function renderStocktakeReport(){
  const metaEl = document.getElementById("stocktakeReportMeta");
  const table = document.getElementById("stocktakeReportTable");
  const rep = window.__stocktake_report__ || { meta:null, rows:[] };

  table.innerHTML = `
    <tr>
      <th style="width:160px;">SKU</th>
      <th>商品</th>
      <th style="width:120px; text-align:right;">前</th>
      <th style="width:120px; text-align:right;">後</th>
      <th style="width:120px; text-align:right;">差分</th>
    </tr>
  `;

  if (!rep.meta || !rep.rows.length){
    metaEl.textContent = "まだ棚卸が実行されていません。";
    const tr = table.insertRow();
    tr.innerHTML = `<td colspan="5" class="center muted">棚卸を実行すると、ここに差分TOP10が出ます</td>`;
    return;
  }

  metaEl.textContent =
    `直近: ${formatDate(rep.meta.at)} / 差分: ${rep.meta.count}件 / update:${rep.meta.updated} insert:${rep.meta.inserted} delete:${rep.meta.deleted} / エラー:${rep.meta.errors}`;

  const top = rep.rows.slice(0, 10);
  top.forEach(r => {
    const tr = table.insertRow();
    tr.innerHTML = `
      <td class="muted">${escapeHtml(r.sku)}</td>
      <td class="nameCell">${escapeHtml(r.name || "")}</td>
      <td class="qty">${Number(r.before)}</td>
      <td class="qty">${Number(r.after)}</td>
      <td class="qty">${Number(r.diff)}</td>
    `;
  });
}

function downloadStocktakeReportCSV(){
  const rep = window.__stocktake_report__;
  if (!rep || !rep.meta || !rep.rows.length){
    alert("棚卸差分レポートがありません（棚卸を実行してから）");
    return;
  }
  let csv = "sku,name,before,after,diff\n";
  rep.rows.forEach(r => {
    csv += `${csvEscape(r.sku)},${csvEscape(r.name||"")},${Number(r.before)},${Number(r.after)},${Number(r.diff)}\n`;
  });
  downloadText(`stocktake_report_${todayStr()}.csv`, csv);
}

function clearStocktakeReport(){
  window.__stocktake_report__ = { meta:null, rows:[] };
  renderStocktakeReport();
  setStatus("棚卸レポートをクリアしました", true);
}

/* ========= 発注アシスト ========= */
function openOrderAssist(){
  // 不足（qty < alert）を元に行を作る
  const stocks = window.__stocks_cache__ || [];
  const low = stocks
    .map(r => {
      const alertQty = getAlertQtyForRow(r);
      const qty = Number(r.qty || 0);
      const shortage = Math.max(0, alertQty - qty);
      return { ...r, alertQty, qty, shortage };
    })
    .filter(r => r.qty < r.alertQty);

  window.__order_rows__ = low.map(r => ({
    sku: String(r.sku || ""),
    name: String(r.name || ""),
    qty: Number(r.qty || 0),
    alert_qty: Number(r.alertQty || DEFAULT_ALERT_QTY),
    shortage: Number(r.shortage || 0),
    order_qty: Number(r.shortage || 0) // 初期値：不足分
  }));

  renderOrderAssistTable();
  alert(`発注アシストを作成しました（${window.__order_rows__.length}件）`);
}

function renderOrderAssistTable(){
  const table = document.getElementById("orderTable");
  const count = document.getElementById("orderCount");
  if (!table || !count) return;

  const rows = window.__order_rows__ || [];
  count.textContent = String(rows.length);

  table.innerHTML = `
    <tr>
      <th style="width:170px;">SKU</th>
      <th style="min-width:340px;">商品</th>
      <th style="width:120px; text-align:right;">在庫</th>
      <th style="width:120px; text-align:right;">アラート</th>
      <th style="width:120px; text-align:right;">不足</th>
      <th style="width:160px; text-align:right;">発注数（入力）</th>
    </tr>
  `;

  if (!rows.length){
    const tr = table.insertRow();
    tr.innerHTML = `<td colspan="6" class="center muted">不足SKUがありません（または未作成）</td>`;
    return;
  }

  rows.forEach((r, idx) => {
    const tr = table.insertRow();
    tr.innerHTML = `
      <td class="muted">${escapeHtml(r.sku)}</td>
      <td class="nameCell">${escapeHtml(r.name)}</td>
      <td class="qty">${Number(r.qty)}</td>
      <td class="qty">${Number(r.alert_qty)}</td>
      <td class="qty">${Number(r.shortage)}</td>
      <td class="qty">
        <input type="number" style="width:140px; text-align:right;" value="${Number(r.order_qty)}"
          oninput="updateOrderQty(${idx}, this.value)" />
      </td>
    `;
  });
}

function updateOrderQty(idx, val){
  const n = Number(val);
  if (!Number.isFinite(n) || n < 0) return;
  if (!window.__order_rows__?.[idx]) return;
  window.__order_rows__[idx].order_qty = n;
}

function downloadOrderCSV(){
  const rows = window.__order_rows__ || [];
  if (!rows.length) return alert("発注アシストが空です（「不足から作成」を押してね）");

  let csv = "sku,name,qty,alert_qty,shortage,order_qty\n";
  rows.forEach(r => {
    csv += `${csvEscape(r.sku)},${csvEscape(r.name)},${Number(r.qty)},${Number(r.alert_qty)},${Number(r.shortage)},${Number(r.order_qty)}\n`;
  });
  downloadText(`order_${todayStr()}.csv`, csv);
  alert("発注CSVを出力しました");
}

/* ========= 日時: JST ========= */
function formatDate(iso){
  try{
    const d = new Date(iso);
    if (isNaN(d.getTime())) return String(iso);

    const parts = new Intl.DateTimeFormat("ja-JP", {
      timeZone: "Asia/Tokyo",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      hour12: false
    }).formatToParts(d);

    const get = (type) => parts.find(p => p.type === type)?.value || "";
    return `${get("year")}-${get("month")}-${get("day")} ${get("hour")}:${get("minute")}:${get("second")}`;
  }catch(e){
    return String(iso);
  }
}

/* ========= escaping ========= */
function escapeHtml(s) {
  return String(s ?? "")
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;")
    .replaceAll('"', "&quot;")
    .replaceAll("'", "&#39;");
}
function escapeJs(s) {
  return String(s ?? "").replaceAll("\\","\\\\").replaceAll("'","\\'").replaceAll("\n"," ").replaceAll("\r"," ");
}
</script>

</body>
</html>
